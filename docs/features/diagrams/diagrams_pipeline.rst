Diagram Rendering Pipeline
========================

This document describes the diagram rendering pipeline in Peta, which processes RST diagram directives and generates SVG graphics during build time.

Overview
--------

The diagram rendering pipeline follows a similar pattern to code blocks and embedded snippet cards, but with full Rust-based SVG generation. Unlike Mermaid.js or other client-side rendering libraries, Peta generates complete SVG markup during the build process, resulting in:

- **No client-side JavaScript rendering required**
- **Fast page load times**
- **Static, cacheable output**
- **Full control over styling and theming**
- **Zero external JavaScript dependencies**

Architecture
------------

The diagram rendering pipeline consists of multiple stages:

.. diagram:: flowchart
   
   RST File -> Directive Processing -> Diagram Parser -> Type-Specific Renderer -> HTML Generation -> Final Output

Stages of the Pipeline
------------------------

1. **RST File Processing**
   The RST file contains diagram directives:

   .. code-block:: rst

      .. diagram:: flowchart
         
         Start -> Process -> Decision -> End

2. **Directive Processing**
   - RstParser identifies the ``.. diagram::`` directive
   - Calls DiagramHandler with the diagram type and content
   - Content is cleaned of paragraph tags

3. **Diagram Parsing**
   DiagramParser parses the text-based diagram syntax:
   
   - ``Flowchart``: ``Node1 -> Node2 -> Node3`` syntax
   - ``Gantt``: ``Task [date] : duration`` syntax
   - ``Sequence``: ``Actor1 -> Actor2: message`` syntax
   - ``Class Diagram``: ``Class1 |+| Class2`` syntax
   - ``State``: ``State1 -> State2 : event`` syntax

4. **Data Model Creation**
   The parser creates structured data models:

   - ``FlowchartDiagram`` with nodes and edges
   - ``GanttDiagram`` with tasks, dates, and dependencies
   - ``SequenceDiagram`` with actors and messages
   - ``ClassDiagram`` with classes and relationships
   - ``StateDiagram`` with states and transitions

5. **Layout Calculation**
   Type-specific renderers calculate node positions:
   
   - Flowchart: Hierarchical BFS-based layout
   - Gantt: Timeline-based horizontal layout
   - Sequence: Lane-based vertical layout
   - Class: Grid-based horizontal layout
   - State: Circular positioning with angles

6. **SVG Generation**
   Renderers generate SVG markup:

   - ``<defs>``: Arrow markers and symbols
   - ``<path>``: Edges, transitions, and connections
   - ``<rect>``: Nodes, classes, and actors
   - ``<circle>``: Initial state indicators
   - ``<text>``: Labels and annotations

7. **HTML Assembly**
   Final HTML output includes:

   .. code-block:: html

      <div class="diagram-container" data-diagram-id="diagram-id" data-diagram-type="flowchart">
        <svg viewBox="0 0 800 400" xmlns="http://www.w3.org/diagrams/svg" class="diagram-svg">
          <!-- SVG content generated by Rust -->
        </svg>
        <details class="diagram-source">
          <summary>View source</summary>
          <pre>diagram syntax</pre>
        </details>
      </div>

Implementation Details
-------------------

Parser (peta/src/content/rst/diagrams/parser.rs)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The DiagramParser is responsible for converting text-based diagram syntax into structured data models.

Key functions:

- ``parse(diagram_type, content)``: Main entry point
- ``parse_flowchart(content)``: Parses ``Node -> Node`` syntax
- ``parse_gantt(content)``: Parses ``Task [date] : duration`` syntax
- ``parse_sequence(content)``: Parses ``Actor -> Actor: message`` syntax
- ``parse_class(content)``: Parses ``Class |+| Class`` syntax
- ``parse_state(content)``: Parses ``State -> State : event`` syntax

Renderers (peta/src/content/rst/diagrams/*.rs)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each diagram type has its own renderer:

- ``FlowchartRenderer``: Hierarchical layout with node positioning
- ``GanttRenderer``: Timeline-based task scheduling
- ``SequenceRenderer``: Actor lane message flow
- ``ClassRenderer``: Component relationship visualization
- ``StateRenderer``: Circular state positioning

Layout Algorithms
~~~~~~~~~~~~~~~~~

**Flowchart Layout:**

1. Identify nodes with no incoming edges (starting points)
2. Use BFS to calculate node levels
3. Group nodes by level
4. Calculate horizontal position for each level (centered)
- Calculate vertical position based on level
5. Place nodes with proper spacing

**Gantt Layout:**

1. Parse task dates and durations
2. Determine project start/end dates
3. Calculate day width based on canvas size
4. Position tasks on timeline
5. Draw grid lines and date labels

**Sequence Layout:**

1. Create actor boxes with unique positions
2. Draw vertical lifelines for each actor
3. Calculate message y-positions
4. Draw horizontal message arrows
5. Add message labels

**Class Layout:**

1. Create class boxes with attributes and methods sections
2. Calculate positions based on relationship complexity
3. Draw relationship lines with appropriate markers
4. Position labels on relationship lines

**State Layout:**

1. Place initial state at starting position
2. Calculate angles for other states
3. Draw transitions with event labels
4. Use circular positioning for states

SVG Generation
~~~~~~~~~~~~~~

SVG is generated directly as strings with proper formatting:

- ViewBox for responsive scaling
- Defs for markers and symbols
- Path elements for edges and lines
- Rect/circle elements for nodes
- Text elements for labels
- CSS classes for styling

Asset Generation
~~~~~~~~~~~~~~

CSS and JavaScript are generated by Rust generators and output to ``_out/dist/assets/``:

- ``diagrams.css``: Container styling, SVG styling, dark mode support
- ``diagrams.js``: Optional interactive features (zoom, pan, tooltips)

Generated by:

- ``DiagramCssGenerator`` (peta/src/assets/css_generator.rs)
- ``DiagramHandler`` (peta/src/content/rst/directives.rs)

Integration Points
~~~~~~~~~~~~~~~~~

The diagram pipeline integrates with:

1. **RST Parser** (peta/src/content/rst/parser.rs):
   - Registers DiagramHandler for ``.. diagram::`` directives
   - Processes directives before markup conversion

2. **Asset Pipeline** (peta/src/assets/pipeline.rs):
   - Calls ``generate_diagram_assets()`` during build
   - Outputs CSS and JS to ``_out/dist/assets/``

3. **Template Engine**:
   - Includes diagram CSS and JS in page templates
   - Links CSS in ``<head>`` section
- Links JS before ``</body>`` tag

Supported Diagram Types
----------------------

Flowchart
~~~~~~~~

Syntax:

.. code-block:: rst

   .. diagram:: flowchart
      
      Start -> Process -> Decision -> End
      Decision -> No -> Process
      Decision -> Yes -> End

Features:

- Hierarchical layout
- Automatic node positioning
- Arrow markers
- Start/End nodes (rounded)
- Decision nodes
- Process nodes

Gantt Chart
~~~~~~~~~~

Syntax:

.. code-block:: rst

   .. diagram:: gantt
      
      Planning [2024-01-01] : 5d
      Development [2024-01-06] : 10d
      Testing [2024-01-16] : 5d
      Deployment [2024-01-21] : 2d

Features:

- Timeline-based layout
- Task bars with duration
- Grid lines for dates
- Date labels
- Task labels

Sequence Diagram
~~~~~~~~~~~~~~~~

Syntax:

.. code-block:: rst

   .. diagram:: sequence
      
      User -> System: Login Request
      System -> Database: Query User
      Database -> System: User Data
      System -> User: Login Success

Features:

- Actor lanes with boxes
- Vertical lifelines
- Message arrows
- Message labels
- Synchronous/async message types

Class Diagram
~~~~~~~~~~~~

Syntax:

.. code-block:: rst

   .. diagram:: class-diagram
      
      User |+| Database
      User |+| API
      API |o| Cache

Features:

- Class boxes with sections
- Relationship markers
- Composition (``|+|``)
- Aggregation (``|o|``)
- Association (``--``)
- Inheritance (``--|>``)

State Diagram
~~~~~~~~~~~~

Syntax:

.. code-block:: rst

   .. diagram:: state
      
      Idle -> Running : start
      Running -> Paused : pause
      Paused -> Running : resume
      - Running -> Idle : stop

Features:

- Circular state positioning
- Initial state indicator
- Transition arrows
- Event labels
- Normal/Final states

Usage Examples
--------------

Basic Flowchart
~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: flowchart
      
      Input -> Process -> Output

Advanced Flowchart with Branching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: flowchart
      
      Start -> Initialize -> Check
      Check -> Valid -> Process
      Check -> Invalid -> Error
      Error -> End
      Process -> End

Project Timeline
~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: gantt
      
      Requirements [2024-01-01] : 5d
      Design [2024-01-06] : 10d
      Implementation [2024-01-16] : 15d
      Testing [2024-01-31] : 10d
      Deployment [2024-02-10] : 5d

API Interaction Sequence
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: sequence
      
      Client -> API: Request
      API -> Database: Query
      Database -> API: Data
      API -> Client: Response

System Architecture
~~~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: class-diagram
      
      Application |o| Database
      Application |+| Cache
      Database |+| Storage

Application State Machine
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. diagram:: state
      
      Idle -> Loading : load
      Loading -> Ready : success
      Loading -> Error : fail
      Ready -> Idle : close
      Error -> Idle : close

Styling and Theming
~~~~~~~~~~~~~~~~~~

Diagram styling is controlled by CSS generated in Rust:

**Container Styling:**

- Border and shadow
- Background color
- Responsive sizing
- Padding and margins

**SVG Styling:**

- Node colors and borders
- Edge stroke width and color
- Text fonts and sizes
- Marker colors and sizes

**Dark Mode Support:**

- Automatic theme detection
- Color scheme switching
- Readability adjustments

**Customization:**

Colors are defined in the DiagramCssGenerator:

- Primary colors: ``#3b82f6`` (blue), ``#2563eb`` (darker blue)
- Text colors: ``#1f2937`` (dark gray), ``#374151`` (medium gray)
- Success colors: ``#d1fae5`` (green), ``#059669`` (dark green)
- Warning colors: ``#fef3c7`` (yellow), ``#differences`` (dark yellow)

Limitations
-----------

Current limitations:

- **Simple layouts**: Layout algorithms are basic (hierarchical, grid-based)
- **Limited node types**: Fixed set of node shapes (rectangles, circles)
- **No subdiagrams**: Cannot embed diagrams within diagrams
- **No interactive features**: Static SVG only (optional JS for zoom/pan)
- **Limited edge routing**: Straight lines only, no curved routing
- **Manual positioning**: No automatic graph optimization

Future Enhancements
--------------------

Potential improvements:

1. **Advanced Layout Algorithms**
   - Force-directed layout for complex graphs
   - Layered algorithms for better flowcharts
   - Orthogonal routing for cleaner edges

2. **Interactive Features**
   - Pan and zoom functionality
   - Node hover effects
   - Click-to-expand details
   - Tooltips with additional info

3. **More Diagram Types**
   - ER diagrams
   - Entity-relationship diagrams
   - Activity diagrams
   - Use case diagrams
   - Network diagrams

4. **Enhanced Styling**
   - Custom node shapes
   - Gradient backgrounds
   - Animation support
   - Export to PNG/SVG

5. **Subdiagram Support**
   - Embedded diagrams within diagrams
   - Expandable/collapsible sections
   - Layered architecture diagrams

6. **Export Functionality**
   - Download as SVG
   - Export to PNG
   - Copy to clipboard

Troubleshooting
-------------

Diagrams Not Rendering
~~~~~~~~~~~~~~~~~~~~~

If diagrams don't appear:

1. Check RST syntax:
   - Ensure ``.. diagram:: type`` format is correct
   - Verify indentation (3 spaces)
   - Check for typos in node names

2. Check build output:
   - Verify ``diagrams.css`` and ``diagrams.js`` are generated
   - Check for compilation errors in diagram renderers

3. Check HTML output:
   - Verify ``<svg>`` tags are present
   - Check for SVG content inside tags
   - Ensure container divs are present

Diagrams Look Wrong
~~~~~~~~~~~~~~~~~~~

If diagrams display incorrectly:

1. Check layout:
   - Verify nodes are positioned correctly
   - Check for overlapping elements
   - Ensure SVG viewBox is correct

2. Check styling:
   - Verify CSS is loaded
   - Check for dark mode issues
   - Ensure SVG classes match CSS

3. Check browser:
   - Try different browsers
   - Check SVG support
   - Verify no CSS conflicts

Build Errors
~~~~~~~~~~~~

Common build errors:

- ``borrow of moved value``: Check ownership in renderer
- ``type annotations needed``: Add explicit types
- ``field is never read``: Add ``#[allow(dead_code)]`` attribute

Performance Considerations
-------------------------

Build-time Rendering Benefits:

- **Fast page loads**: SVG is pre-generated
- **No runtime computation**: Client just displays HTML
- **Cacheable**: Output is static
- **SEO friendly**: SVG content is indexable

Performance Impact:

- Build time increase: ~50-100ms per diagram
- File size: ~2-5KB per diagram (SVG markup)
- No runtime overhead: Zero JavaScript execution

Optimization Tips:

- Reuse common patterns for similar diagrams
- Limit diagram complexity for better layout
- Use CSS for animations instead of JavaScript
- Minimize SVG element count where possible

Best Practices
-------------

1. **Keep diagrams simple**: Complex graphs may not layout well
2. **Use descriptive names**: Node names should be clear
3. **Follow syntax patterns**: Use consistent formatting
4. **Test incrementally**: Build and check each diagram
5. **Document complex diagrams**: Add comments in RST
6. **Use appropriate types**: Choose right diagram for the data

Example: Creating a Documentation Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: rst

   .. _diagram-guide:

   Diagram Guide
   =============

   This guide shows how to use diagrams in your documentation.

   Process Flow
   ~~~~~~~~~~~~

   .. diagram:: flowchart
      
      Plan -> Design -> Implement -> Test -> Deploy

   Timeline
   ~~~~~~~~

   .. diagram:: gantt
      
      Phase 1 [2024-01-01] : 2w
      Phase 2 [2024-01-15] : 3w
      Phase 3 [2024-02-05] : 2w

   API Workflow
   ~~~~~~~~~~~~~

   .. diagram:: sequence
      
      Client -> API: authenticate
      API -> Auth: validate
      Auth -> API: token
      API -> Client: response

   System Architecture
   ~~~~~~~~~~~~~~~~~~~~

   .. diagram:: class-diagram
      
      Core |+| Database
      Core |+| Cache
      Core |o| External APIs

   Application States
   ~~~~~~~~~~~~~~~~~~~

   .. diagram:: state
      
      Offline -> Syncing : connect
      Syncing -> Online : success
      Online -> Offline : disconnect
      Online -> Syncing : refresh

Additional Resources
--------------------

- :doc:`/features/rst_parser/rst_parsing_pipeline`: RST parsing details
- :doc:`/features/codeblocks/codeblocks_pipeline`: Code block implementation
- :doc:`/features/math_formulas/math_formulas_pipeline`: Math formula rendering
- ``peta/src/content/rst/diagrams/``: Source code
- `docs/features/diagrams/diagrams_design_spec.rst`: Design specification

Summary
-------

The diagram rendering pipeline provides a robust, Rust-based solution for generating SVG graphics from RST diagram directives. With full build-time rendering, no client-side dependencies, and complete control over styling, Peta delivers fast, cacheable, and customizable diagram output for technical documentation.