//! JavaScript generator for code block interactions

use crate::core::Result;
use serde::{Deserialize, Serialize};

/// JavaScript generator for code block functionality
pub struct JsGenerator {
    /// Configuration
    config: JsConfig,
}

/// Configuration for JavaScript generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsConfig {
    /// Enable copy functionality
    pub enable_copy: bool,
    /// Enable keyboard shortcuts
    pub enable_keyboard_shortcuts: bool,
    /// Enable line hover effects
    pub enable_line_hover: bool,
    /// Copy success duration in milliseconds
    pub copy_success_duration: u64,
}

impl Default for JsConfig {
    fn default() -> Self {
        Self {
            enable_copy: true,
            enable_keyboard_shortcuts: true,
            enable_line_hover: true,
            copy_success_duration: 2000,
        }
    }
}

impl JsGenerator {
    /// Create a new JavaScript generator with default configuration
    pub fn new() -> Self {
        Self::with_config(JsConfig::default())
    }

    /// Create a JavaScript generator with custom configuration
    pub fn with_config(config: JsConfig) -> Self {
        Self { config }
    }

    /// Generate complete JavaScript for code blocks
    pub fn generate(&self) -> Result<String> {
        let mut js = String::new();

        js.push_str("/**\n");
        js.push_str(" * Code Block Component JavaScript\n");
        js.push_str(" * Generated by Peta Static Site Generator\n");
        js.push_str(" */\n\n");

        // Copy functionality
        if self.config.enable_copy {
            js.push_str(&self.generate_copy_function());
        }

        // Line hover effects
        if self.config.enable_line_hover {
            js.push_str(&self.generate_line_hover_function());
        }

        // Keyboard shortcuts
        if self.config.enable_keyboard_shortcuts {
            js.push_str(&self.generate_keyboard_shortcuts_function());
        }

        // Initialization
        js.push_str(&self.generate_initialization());

        Ok(js)
    }

    /// Generate copy to clipboard function
    fn generate_copy_function(&self) -> String {
        let duration = self.config.copy_success_duration;

        format!(
            r#"
/**
 * Copy code to clipboard with enhanced feedback
 * @param button - The copy button element
 */
function copyCode(button) {{
    const codeBlock = button.closest('.code-block');
    const codeElement = codeBlock.querySelector('code');
    const text = codeElement.textContent;

    navigator.clipboard.writeText(text).then(() => {{
        const originalText = button.innerHTML;
        button.classList.add('copied');
        button.innerHTML = `
            <svg class="code-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            <span class="copy-text">Copied!</span>
        `;

        // Visual feedback
        button.style.background = 'rgba(16, 185, 129, 0.2)';
        button.style.borderColor = 'rgba(16, 185, 129, 0.5)';

        setTimeout(() => {{
            button.innerHTML = originalText;
            button.classList.remove('copied');
            button.style.background = '';
            button.style.borderColor = '';
        }}, {});
    }}).catch(err => {{
        console.error('Failed to copy code:', err);
        // Show error feedback
        button.style.background = 'rgba(239, 68, 68, 0.2)';
        button.style.borderColor = 'rgba(239, 68, 68, 0.5)';
        button.innerHTML = `
            <svg class="code-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <span class="copy-text">Error</span>
        `;

        setTimeout(() => {{
            button.innerHTML = `
                <svg class="code-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                <span class="copy-text">Copy</span>
            `;
            button.style.background = '';
            button.style.borderColor = '';
        }}, {});
    }});
}}

"#,
            duration, duration
        )
    }

    /// Generate line hover effects function
    fn generate_line_hover_function(&self) -> String {
        r#"
/**
 * Initialize line hover effects for code blocks
 */
function initializeLineHoverEffects() {
    const codeBlocks = document.querySelectorAll('.code-block');

    codeBlocks.forEach(block => {
        const lines = block.querySelectorAll('.line-number');

        lines.forEach((line, index) => {
            line.addEventListener('mouseenter', function() {
                const lineNumber = parseInt(this.getAttribute('data-line'));
                const codeLines = block.querySelectorAll('code > span');

                // Highlight the current line
                if (codeLines[lineNumber - 1]) {
                    codeLines[lineNumber - 1].style.background = 'rgba(59, 130, 246, 0.1)';
                }
            });

            line.addEventListener('mouseleave', function() {
                const lineNumber = parseInt(this.getAttribute('data-line'));
                const codeLines = block.querySelectorAll('code > span');

                // Remove highlight
                if (codeLines[lineNumber - 1]) {
                    codeLines[lineNumber - 1].style.background = '';
                }
            });
        });
    });
}

"#
        .to_string()
    }

    /// Generate keyboard shortcuts function
    fn generate_keyboard_shortcuts_function(&self) -> String {
        r#"
/**
 * Initialize keyboard shortcuts for code blocks
 */
function initializeKeyboardShortcuts() {
    document.addEventListener('keydown', function(event) {
        // Ctrl/Cmd + K to copy focused code block
        if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
            const focusedElement = document.activeElement;
            const codeBlock = focusedElement.closest('.code-block');

            if (codeBlock) {
                const copyButton = codeBlock.querySelector('.code-copy-button');
                if (copyButton) {
                    event.preventDefault();
                    copyButton.click();
                }
            }
        }
    });
}

"#
        .to_string()
    }

    /// Generate initialization code
    fn generate_initialization(&self) -> String {
        let mut init = String::new();

        init.push_str("/**\n");
        init.push_str(" * Initialize code block enhancements when DOM is ready\n");
        init.push_str(" */\n");
        init.push_str("document.addEventListener('DOMContentLoaded', function() {\n");

        if self.config.enable_line_hover {
            init.push_str("    initializeLineHoverEffects();\n");
        }

        if self.config.enable_keyboard_shortcuts {
            init.push_str("    initializeKeyboardShortcuts();\n");
        }

        init.push_str("});\n\n");

        // Export for external use
        init.push_str("/**\n");
        init.push_str(" * Export functions for external use\n");
        init.push_str(" */\n");
        init.push_str("window.CodeBlockComponent = {\n");

        if self.config.enable_copy {
            init.push_str("    copyCode,\n");
        }

        if self.config.enable_line_hover {
            init.push_str("    initializeLineHoverEffects,\n");
        }

        if self.config.enable_keyboard_shortcuts {
            init.push_str("    initializeKeyboardShortcuts\n");
        }

        init.push_str("};\n");

        init
    }

    /// Set configuration
    pub fn set_config(&mut self, config: JsConfig) {
        self.config = config;
    }

    /// Get configuration
    pub fn config(&self) -> &JsConfig {
        &self.config
    }
}

impl Default for JsGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_js_generation() {
        let generator = JsGenerator::new();
        let js = generator.generate().unwrap();

        assert!(js.contains("function copyCode"));
        assert!(js.contains("function initializeLineHoverEffects"));
        assert!(js.contains("function initializeKeyboardShortcuts"));
        assert!(js.contains("document.addEventListener('DOMContentLoaded'"));
        assert!(js.contains("window.CodeBlockComponent"));
    }

    #[test]
    fn test_js_without_copy() {
        let config = JsConfig {
            enable_copy: false,
            ..Default::default()
        };
        let generator = JsGenerator::with_config(config);
        let js = generator.generate().unwrap();

        assert!(!js.contains("function copyCode"));
    }

    #[test]
    fn test_js_without_keyboard_shortcuts() {
        let config = JsConfig {
            enable_keyboard_shortcuts: false,
            ..Default::default()
        };
        let generator = JsGenerator::with_config(config);
        let js = generator.generate().unwrap();

        assert!(!js.contains("function initializeKeyboardShortcuts"));
    }

    #[test]
    fn test_custom_copy_duration() {
        let config = JsConfig {
            copy_success_duration: 3000,
            ..Default::default()
        };
        let generator = JsGenerator::with_config(config);
        let js = generator.generate().unwrap();

        assert!(js.contains("}, 3000)"));
    }

    #[test]
    fn test_minimal_js() {
        let config = JsConfig {
            enable_copy: false,
            enable_keyboard_shortcuts: false,
            enable_line_hover: false,
            ..Default::default()
        };
        let generator = JsGenerator::with_config(config);
        let js = generator.generate().unwrap();

        assert!(!js.contains("copyCode"));
        assert!(!js.contains("initializeLineHoverEffects"));
        assert!(!js.contains("initializeKeyboardShortcuts"));
    }
}

/// JavaScript generator for embedded snippet card functionality
pub struct EmbeddedSnippetCardJsGenerator {
    /// Configuration
    config: EmbeddedSnippetCardConfig,
}

/// Configuration for embedded snippet card JS generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbeddedSnippetCardConfig {
    /// Enable collapse/expand functionality
    pub enable_collapse: bool,
    /// Max height before collapse (in pixels)
    pub collapse_threshold: String,
    /// Show "View in modal" button
    pub show_modal_button: bool,
}

impl Default for EmbeddedSnippetCardConfig {
    fn default() -> Self {
        Self {
            enable_collapse: true,
            collapse_threshold: "400px".to_string(),
            show_modal_button: true,
        }
    }
}

impl EmbeddedSnippetCardJsGenerator {
    /// Create a new embedded snippet card JS generator
    pub fn new() -> Result<Self> {
        Ok(Self {
            config: EmbeddedSnippetCardConfig::default(),
        })
    }

    /// Create a JS generator with custom configuration
    pub fn with_config(config: EmbeddedSnippetCardConfig) -> Result<Self> {
        Ok(Self { config })
    }

    /// Generate complete JavaScript for embedded snippet cards
    pub fn generate(&self) -> Result<String> {
        let mut js = String::new();

        js.push_str("(function() {\n");
        js.push_str("  'use strict';\n\n");
        
        // Collapse/expand functionality
        if self.config.enable_collapse {
            js.push_str(&self.generate_collapse_functionality());
        }

        // Modal button functionality
        if self.config.show_modal_button {
            js.push_str(&self.generate_modal_button_functionality());
        }

        // Initialization function
        js.push_str("  function initEmbeddedSnippetCards() {\n");
        if self.config.enable_collapse {
            js.push_str("    initCollapse();\n");
        }
        if self.config.show_modal_button {
            js.push_str("    addModalButtons();\n");
        }
        js.push_str("  }\n");

        js.push_str("  // Initialize on DOM content loaded\n");
        js.push_str("  if (document.readyState === 'loading') {\n");
        js.push_str("    document.addEventListener('DOMContentLoaded', initEmbeddedSnippetCards);\n");
        js.push_str("  } else {\n");
        js.push_str("    initEmbeddedSnippetCards();\n");
        js.push_str("  }\n");

        js.push_str("})();\n");

        Ok(js)
    }

    /// Generate collapse/expand functionality
    fn generate_collapse_functionality(&self) -> String {
        format!(
            r#"  // Initialize collapse functionality
  function initCollapse() {{
    const cards = document.querySelectorAll('.embedded-snippet-card');
    
    cards.forEach(card => {{
      const content = card.querySelector('.embedded-snippet-content');
      if (!content) return;
      
      // Check if content exceeds threshold
      if (content.scrollHeight > parseInt('{}')) {{
        addCollapseButton(card, content);
      }}
    }});
  }}
  
  // Add collapse button to card
  function addCollapseButton(card, content) {{
    const button = document.createElement('button');
    button.className = 'embedded-snippet-toggle';
    button.innerHTML = 'Show More';
    button.setAttribute('aria-expanded', 'false');
    
    button.addEventListener('click', function() {{
      const isExpanded = content.style.maxHeight !== '{}';
      if (isExpanded) {{
        content.style.maxHeight = '{}';
        content.style.overflow = 'hidden';
        button.innerHTML = 'Show More';
        button.setAttribute('aria-expanded', 'false');
      }} else {{
        content.style.maxHeight = 'none';
        content.style.overflow = 'visible';
        button.innerHTML = 'Show Less';
        button.setAttribute('aria-expanded', 'true');
      }}
    }});
    
    const header = card.querySelector('.embedded-snippet-header');
    if (header) {{
      header.appendChild(button);
    }} else {{
      card.insertBefore(button, content);
    }}
  }}
  
"#,
            self.config.collapse_threshold,
            self.config.collapse_threshold,
            self.config.collapse_threshold
        )
    }

    /// Generate modal button functionality
    fn generate_modal_button_functionality(&self) -> String {
        r#"  // Add "View in modal" buttons
  function addModalButtons() {
    const cards = document.querySelectorAll('.embedded-snippet-card[data-snippet-id]');
    
    cards.forEach(card => {
      const snippetId = card.getAttribute('data-snippet-id');
      if (!snippetId) return;
      
      const footer = card.querySelector('.embedded-snippet-footer');
      if (!footer) return;
      
      const existingButton = footer.querySelector('.embedded-snippet-modal-btn');
      if (existingButton) return;
      
      const button = document.createElement('button');
      button.className = 'embedded-snippet-modal-btn';
      button.innerHTML = 'ðŸ“– Open in Modal';
      
      button.addEventListener('click', function() {
        if (typeof window.openSnippetModal === 'function') {
          // Fetch snippet data
          fetch(`/snippets/${snippetId}.json`)
            .then(response => response.json())
            .then(data => {
              window.openSnippetModal({
                title: data.title,
                language: data.language,
                content: data.content,
                date: data.date,
                tags: data.tags
              });
            })
            .catch(err => {
              console.error('Failed to load snippet:', err);
            });
        } else {
          console.warn('openSnippetModal function not available');
        }
      });
      
      footer.appendChild(button);
    });
  }
  
"#
        .to_string()
    }
}

impl Default for EmbeddedSnippetCardJsGenerator {
    fn default() -> Self {
        Self::new().expect("Failed to create EmbeddedSnippetCardJsGenerator")
    }
}

/// JavaScript generator for diagram interactions
pub struct DiagramJsGenerator {
    /// Configuration
    config: DiagramJsConfig,
}

/// Configuration for diagram JS generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiagramJsConfig {
    /// Enable zoom
    pub enable_zoom: bool,
    /// Enable pan
    pub enable_pan: bool,
    /// Enable tooltips
    pub enable_tooltips: bool,
}

impl Default for DiagramJsConfig {
    fn default() -> Self {
        Self {
            enable_zoom: false,
            enable_pan: false,
            enable_tooltips: false,
        }
    }
}

impl DiagramJsGenerator {
    /// Create a new diagram JS generator
    pub fn new() -> Result<Self> {
        Ok(Self {
            config: DiagramJsConfig::default(),
        })
    }

    /// Create a JS generator with custom configuration
    pub fn with_config(config: DiagramJsConfig) -> Result<Self> {
        Ok(Self { config })
    }

    /// Generate complete JavaScript for diagrams
    pub fn generate(&self) -> Result<String> {
        let js = r#"
/**
 * Diagram Component JavaScript
 * Generated by Peta Static Site Generator
 * All SVG rendering is done server-side in Rust
 */

(function() {
  'use strict';

  /**
   * Download diagram as SVG with copyright text
   */
  function downloadDiagram(button) {
    const container = button.closest('.diagram-container');
    const svg = container.querySelector('.diagram-svg');
    const diagramType = button.getAttribute('data-diagram-type') || 'diagram';
    const diagramId = button.getAttribute('data-diagram-id') || 'diagram';

    if (!svg) {
      console.error('SVG element not found');
      return;
    }

    // Clone the SVG to avoid modifying the displayed version
    const svgClone = svg.cloneNode(true);
    
    // Add copyright text to the downloaded SVG
    addCopyrightToSVG(svgClone);

    // Convert to string
    const svgString = new XMLSerializer().serializeToString(svgClone);
    
    // Create blob and download
    const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const filename = `${diagramType}-${diagramId}.svg`;
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Cleanup
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  /**
   * Add copyright text to SVG
   * Format: Â© Site Name (page URL)
   */
  function addCopyrightToSVG(svg) {
    // Get current page URL
    const currentPageUrl = window.location.href;
    
    // Get site name from meta tag or default
    const siteName = document.querySelector('meta[property="og:site_name"]')?.content || 
                     document.querySelector('meta[name="application-name"]')?.content ||
                     'Peta';

    // Copyright text
    const copyrightText = `Â© ${siteName} (${currentPageUrl})`;
    
    // Parse viewBox to get dimensions
    const viewBox = svg.getAttribute('viewBox');
    let width = 800, height = 400, x = 0, y = 0;
    
    if (viewBox) {
      const parts = viewBox.split(/[\s,]+/).map(Number);
      if (parts.length === 4) {
        [x, y, width, height] = parts;
      } else if (parts.length === 2) {
        [width, height] = parts;
      }
    }

    // Calculate space needed for copyright
    const fontSize = 10;
    const lineHeight = 12;
    const padding = 10;
    const bottomPadding = 30;

    // Split text into lines if it's too long
    const maxWidth = width - 2 * padding;
    const textLines = wrapText(copyrightText, maxWidth, fontSize);
    const extraHeight = textLines.length * lineHeight + padding + bottomPadding;

    // Create copyright text element
    const copyrightGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    copyrightGroup.setAttribute('class', 'diagram-copyright');
    
    let currentY = height + fontSize + padding;
    
    textLines.forEach((line, index) => {
      const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      textElement.setAttribute('x', padding.toString());
      textElement.setAttribute('y', currentY.toString());
      textElement.setAttribute('font-size', fontSize.toString());
      textElement.setAttribute('font-family', 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
      textElement.setAttribute('fill', '#9ca3af');
      textElement.textContent = line;
      copyrightGroup.appendChild(textElement);
      currentY += lineHeight;
    });

    // Update viewBox to accommodate copyright
    const newHeight = height + extraHeight;
    svg.setAttribute('viewBox', `${x} ${y} ${width} ${newHeight}`);

    // Add copyright to SVG
    svg.appendChild(copyrightGroup);
  }

  /**
   * Wrap text to fit within a maximum width
   */
  function wrapText(text, maxWidth, fontSize) {
    // Approximate character width (roughly 0.6 * fontSize for most fonts)
    const charWidth = fontSize * 0.6;
    const maxCharsPerLine = Math.floor(maxWidth / charWidth);
    
    if (text.length <= maxCharsPerLine) {
      return [text];
    }

    const lines = [];
    const words = text.split(' ');
    let currentLine = '';

    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      
      if (testLine.length <= maxCharsPerLine) {
        currentLine = testLine;
      } else {
        if (currentLine) {
          lines.push(currentLine);
        }
        currentLine = word;
      }
    }

    if (currentLine) {
      lines.push(currentLine);
    }

    return lines;
  }

  /**
   * Initialize download buttons
   */
  function initDownloadButtons() {
    const downloadButtons = document.querySelectorAll('.diagram-download');
    
    downloadButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        downloadDiagram(this);
      });
    });
  }

  /**
   * Initialize on DOM content loaded
   */
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDownloadButtons);
  } else {
    initDownloadButtons();
  }

  /**
   * Re-initialize when new content is loaded (for dynamic content)
   */
  window.initDiagramDownloadButtons = initDownloadButtons;
})();
"#;

    Ok(js.to_string())
    }

    /// Set configuration
    pub fn set_config(&mut self, config: DiagramJsConfig) {
        self.config = config;
    }

    /// Get configuration
    pub fn config(&self) -> &DiagramJsConfig {
        &self.config
    }
}

impl Default for DiagramJsGenerator {
    fn default() -> Self {
        Self::new().expect("Failed to create DiagramJsGenerator")
    }
}

/// Configuration for music score JavaScript generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MusicScoreJsConfig {
    /// Enable download functionality
    pub enable_download: bool,
    /// Download success duration in milliseconds
    pub download_success_duration: u64,
}

impl Default for MusicScoreJsConfig {
    fn default() -> Self {
        Self {
            enable_download: true,
            download_success_duration: 2000,
        }
    }
}

/// JavaScript generator for music score functionality
pub struct MusicScoreJsGenerator {
    /// Configuration
    config: MusicScoreJsConfig,
}

impl MusicScoreJsGenerator {
    /// Create a new music score JavaScript generator
    pub fn new() -> Result<Self> {
        Ok(Self {
            config: MusicScoreJsConfig::default(),
        })
    }

    /// Create a JavaScript generator with custom configuration
    pub fn with_config(config: MusicScoreJsConfig) -> Result<Self> {
        Ok(Self { config })
    }

    /// Generate complete JavaScript for music scores
    pub fn generate(&self) -> Result<String> {
        let mut js = String::new();

        js.push_str("/**\n");
        js.push_str(" * Music Score Component JavaScript\n");
        js.push_str(" * Generated by Peta Static Site Generator\n");
        js.push_str(" */\n\n");

        // Download functionality
        if self.config.enable_download {
            js.push_str(&self.generate_download_function());
        }

        // Initialization
        js.push_str(&self.generate_initialization());

        Ok(js)
    }

    /// Generate download function
    fn generate_download_function(&self) -> String {
        r##"
/**
 * Download music score as SVG with copyright
 * @param button - The download button element
 */
function downloadMusicScore(button) {
  const container = button.closest('.music-score-container');
  const svg = container.querySelector('.music-score-svg');
  
  if (!svg) {
    console.error('SVG element not found');
    return;
  }
  
  // Clone SVG to modify it
  const clonedSvg = svg.cloneNode(true);
  
  // Get SVG dimensions
  const viewBox = clonedSvg.getAttribute('viewBox');
  const [x, y, width, height] = viewBox.split(' ').map(Number);
  
  // Calculate space needed for copyright
  const fontSize = 10;
  const lineHeight = 12;
  const padding = 10;
  const bottomPadding = 30;
  
  // Get site name and current page URL dynamically
  const pageUrl = window.location.href;
  
  // Get site name from meta tag or default (same as diagram download)
  const siteName = document.querySelector('meta[property="og:site_name"]')?.content || 
                   document.querySelector('meta[name="application-name"]')?.content ||
                   'Peta';
  
  // Create copyright text
  const copyrightText = 'Â© ' + siteName + ' (' + pageUrl + ')';
  
  // Split text into lines if it's too long
  const maxWidth = width - 2 * padding;
  const textLines = wrapText(copyrightText, maxWidth, fontSize);
  const extraHeight = textLines.length * lineHeight + padding + bottomPadding;
  
  // Create copyright text element
  const copyrightGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  copyrightGroup.setAttribute('class', 'music-score-copyright');
  
  let currentY = height + fontSize + padding;
  
  textLines.forEach((line, index) => {
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    textElement.setAttribute('x', padding.toString());
    textElement.setAttribute('y', currentY.toString());
    textElement.setAttribute('font-size', fontSize.toString());
    textElement.setAttribute('font-family', 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');
    textElement.setAttribute('fill', '#9ca3af');
    textElement.textContent = line;
    copyrightGroup.appendChild(textElement);
    currentY += lineHeight;
  });
  
  // Update viewBox to accommodate copyright
  const newHeight = height + extraHeight;
  clonedSvg.setAttribute('viewBox', x + ' ' + y + ' ' + width + ' ' + newHeight);
  
  // Add copyright to SVG
  clonedSvg.appendChild(copyrightGroup);
  
  // Serialize SVG to string
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(clonedSvg);
  
  // Create blob and download
  const blob = new Blob([svgString], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'music-score.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Wrap text to fit within a maximum width
 */
function wrapText(text, maxWidth, fontSize) {
  // Approximate character width (roughly 0.6 * fontSize for most fonts)
  const charWidth = fontSize * 0.6;
  const maxCharsPerLine = Math.floor(maxWidth / charWidth);
  
  if (text.length <= maxCharsPerLine) {
    return [text];
  }
  
  const lines = [];
  const words = text.split(' ');
  let currentLine = '';
  
  for (const word of words) {
    const testLine = currentLine ? currentLine + ' ' + word : word;
    
    if (testLine.length <= maxCharsPerLine) {
      currentLine = testLine;
    } else {
      if (currentLine) {
        lines.push(currentLine);
      }
      currentLine = word;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}
"##.to_string()
    }

    /// Generate initialization code
    fn generate_initialization(&self) -> String {
        r#"
/**
 * Initialize download buttons
 */
function initMusicScoreDownloadButtons() {
  const downloadButtons = document.querySelectorAll('.music-score-download');
  
  downloadButtons.forEach(button => {
    button.addEventListener('click', function(e) {
      e.preventDefault();
      downloadMusicScore(this);
    });
  });
}

/**
 * Initialize on DOM content loaded
 */
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMusicScoreDownloadButtons);
} else {
  initMusicScoreDownloadButtons();
}

/**
 * Re-initialize when new content is loaded (for dynamic content)
 */
window.initMusicScores = function() {
  initMusicScoreDownloadButtons();
};
"#
        .to_string()
    }

    /// Set configuration
    pub fn set_config(&mut self, config: MusicScoreJsConfig) {
        self.config = config;
    }

    /// Get configuration
    pub fn config(&self) -> &MusicScoreJsConfig {
        &self.config
    }
}

impl Default for MusicScoreJsGenerator {
    fn default() -> Self {
        Self::new().expect("Failed to create MusicScoreJsGenerator")
    }
}